package httpmiddleware

import (
	"net/http"
	"strings"

	"github.com/go-chi/render"
	"gitlab.edgecastcdn.net/edgecast/web-platform/identity/goutils/jwtverifier"
	"gitlab.edgecastcdn.net/edgecast/web-platform/identity/goutils/log"
)

// AuthTokenVerifier is an interface that can verify access tokens. The jwtverifier.JwtVerifier is a struct
// that implements this interface.
type AuthTokenVerifier interface {
	// VerifyAccessToken verifies the token against the ID Provider's public cert and then returns the
	// claims as a map[string]any
	VerifyAccessToken(token string) (map[string]any, error)
}

// UnauthorizedError is an interface that is used as an error response payload
// when a request is not authorized.
type UnauthorizedError interface {
	render.Renderer

	// AddDetail adds an error detail to the Details collection.
	// source represents a JSON Pointer [RFC6901] as string.
	// description is a detail description about the error as string.
	AddDetail(source *string, description string)
}

// MiddlewareFunc represents a middleware func that can be used in chi options.
// This handler is originally defined by the server code generated by oapi-codegen
// but is redeclared here so that it can be reused.
type MiddlewareFunc func(http.Handler) http.Handler

// ValidateAuthToken reads the Authorization header, verifies the token and saves the claims inside a new context.
// The request's context is replaced with this new context.
// The AuthorizeRequest middleware should be run after this.
func ValidateAuthToken(verifier AuthTokenVerifier, newUnauthorizedError func() UnauthorizedError) MiddlewareFunc {
	return func(next http.Handler) http.Handler {
		fn := func(w http.ResponseWriter, r *http.Request) {
			auth := r.Header.Get("Authorization")
			if len(auth) < 7 {
				renderInvalidBearerError(w, r, newUnauthorizedError)

				return
			}
			authType := strings.ToLower(auth[:6])
			if authType != "bearer" {
				renderInvalidBearerError(w, r, newUnauthorizedError)

				return
			}
			tokenString := auth[7:]

			claims, err := verifier.VerifyAccessToken(tokenString)
			if err != nil {
				log.FromContext(r.Context()).Infow("Could not verify access token", "error", err)

				unauthErr := newUnauthorizedError()
				_ = render.Render(w, r, unauthErr)

				return
			}

			newRequest := r.WithContext(jwtverifier.NewContext(r.Context(), claims))

			next.ServeHTTP(w, newRequest)
		}

		return http.HandlerFunc((fn))
	}
}

const (
	// BearerAuthScopes is originally defined by the server code generated by oapi-codegen
	// but is redeclared here so that it can be reused. This value is used to look up
	// a value in context.Context
	BearerAuthScopes = "bearerAuth.Scopes"
)

// AuthorizeRequest takes the claims written in the context via ValidateAuthToken middleware, and compares it
// with the scopes that are needed for the current endpoint. The needed scopes originate from a value in the context
// with the key BearerAuthScopes. This is set by the generated server code.
func AuthorizeRequest(newUnauthorizedError func() UnauthorizedError) MiddlewareFunc {
	return func(next http.Handler) http.Handler {

		fn := func(w http.ResponseWriter, r *http.Request) {
			log := log.FromContext(r.Context())

			claims := jwtverifier.ClaimsFromContext(r.Context())
			if claims == nil {
				log.Warn("Could not get claims from context")

				unauthErr := newUnauthorizedError()
				_ = render.Render(w, r, unauthErr)

				return
			}

			scopes, ok := claims["scope"].([]any)
			if !ok {
				log.Warn("Could not parse 'scope' claim from claims")

				unauthErr := newUnauthorizedError()
				_ = render.Render(w, r, unauthErr)

				return
			}

			neededScopes, ok := r.Context().Value(BearerAuthScopes).([]string)
			if !ok {
				log.Warn("Could not get endpoint needed scopes from context")

				unauthErr := newUnauthorizedError()
				_ = render.Render(w, r, unauthErr)

				return
			}

			if !containsAny(scopes, neededScopes) {
				unauthErr := newUnauthorizedError()
				unauthErr.AddDetail(nil, "You do not have permission to resource or to perform this action")
				_ = render.Render(w, r, unauthErr)

				return
			}

			next.ServeHTTP(w, r)
		}
		return http.HandlerFunc(fn)
	}
}

func renderInvalidBearerError(w http.ResponseWriter, r *http.Request, newUnauthorizedError func() UnauthorizedError) {
	unauthErr := newUnauthorizedError()
	unauthErr.AddDetail(nil, "Invalid bearer authorization header")
	_ = render.Render(w, r, unauthErr)
}

func containsAny(scopes []any, searchScopes []string) bool {
	for _, val := range scopes {
		scope, ok := val.(string)
		if !ok {
			continue
		}

		for _, searchScope := range searchScopes {
			if scope == searchScope {
				return true
			}
		}
	}
	return false
}
